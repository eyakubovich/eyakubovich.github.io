---
layout: post
title: Recursing constexpr - Part II
date: '2012-03-03T16:29:00.000-08:00'
author: Eugene Yakubovich
tags:
- C++
- C++11
- metaprogramming
modified_time: '2012-04-19T10:04:19.004-07:00'
thumbnail: http://3.bp.blogspot.com/-Clovhp7d2KY/T0wbwEtqoLI/AAAAAAAAAAU/s5aVx2jSpL0/s72-c/while-loop.png
blogger_id: tag:blogger.com,1999:blog-7098284592115366563.post-6724305023619124011
blogger_orig_url: http://dev-perspective.blogspot.com/2012/03/recursing-constexpr-part-ii.html
---

In the <a href="{{ site.baseurl }}{% post_url 2012-02-24-recursing-constexpr %}">previous post</a>, we developed a logarithmic depth accumulate() function that can be used to emulate a for-loop. In this post, we'll look at how to construct a  function that emulates a while-loop with the recursive depth of <i>O(lg(n))</i> where <i>n</i> is the number of iterations of the while-loop. Recall that our initial motivation is to be able to determine if a large number is prime at compile time as was done in <a href="http://cpptruths.blogspot.com/2011/07/want-speed-use-constexpr-meta.html">this post</a>.<br /><br />A while-loop can be generally written as follows:<br /><br />state = initial state;<br />while( test(state) )<br />&nbsp; &nbsp; mutate state;<br /><br />Translating this to functional form, we can write the signature as:<br /><br /><pre class="brush: cpp">template &lt;typename T, typename Test, typename Op&gt;<br />T while_loop(T init, Test test, Op op);<br /></pre><br />The main idea behind the implementation of while_loop() is to call a helper function that will execute up to <i>n</i> iterations of the loop. As we have seen in previous post, this can be done with recursive depth of <i>O(lg(n))</i>. If there are more iterations that are still needed (that is test(state) is still true), while_loop() recursively calls itself with <i>2n</i>. Instead of <i>n</i>, the implementation uses <i>depth</i> argument to signify the maximum recursion depth.&nbsp;This is illustrated below:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-Clovhp7d2KY/T0wbwEtqoLI/AAAAAAAAAAU/s5aVx2jSpL0/s1600/while-loop.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="211" src="http://3.bp.blogspot.com/-Clovhp7d2KY/T0wbwEtqoLI/AAAAAAAAAAU/s5aVx2jSpL0/s400/while-loop.png" width="400" /></a></div><br />The code looks like this:<br /><br /><pre class="brush: cpp">template &lt;typename T, typename Test, typename Op&gt;<br />constexpr T exec(int first, int last, T init, Test test, Op op) {<br />    return<br />        (first &gt;= last || !test(init)) ? init :<br />            (first + 1 == last) ?<br />                op(init) :<br />                exec((first + last) / 2, last,<br />                    exec(first, (first + last) / 2, init, test, op), test, op);<br />}<br /><br />template &lt;typename T, typename Test, typename Op&gt;<br />constexpr T while_loop(T init, Test test, Op op, int depth = 1) {<br />    return !test(init) ? init :<br />        while_loop(exec(0, (1 &lt;&lt; depth) - 1, init, test, op), test, op, depth+1);<br />}<br /></pre><br />There is one downside to this algorithm. The exec() function performs the test to determine if it should continue or bail at the point of entry. This performs more tests than necessary. For example, as exec() recurses along the left edge of the tree, it performs the test over and over without mutating the state. This can be fixed by introducing another helper and performing the test only on the right branch of the recursion:<br /><br /><pre class="brush: cpp">template &lt;typename T, typename Test, typename Op&gt;<br />constexpr T guarded_exec(int first, int last, T init, Test test, Op op) {<br />    return test(init) ? exec(first, last, init, test, op) : init;<br />}<br /><br />template &lt;typename T, typename Test, typename Op&gt;<br />constexpr T exec(int first, int last, T init, Test test, Op op) {<br />    return<br />        (first &gt;= last) ? init :<br />            (first + 1 == last) ?<br />                op(init) :<br />                guarded_exec((first + last) / 2, last,<br />                    exec(first, (first + last) / 2, init, test, op), test, op);<br />}<br /></pre><br />Finally, we can use while_loop() to implement is_prime():<br /><br /><pre class="brush: cpp">struct test_expr {<br />    int n;<br />    constexpr bool operator()(int x) const { return x*x &lt;= n &amp;&amp; n % x != 0; }<br />};<br /><br />constexpr int inc(int x) {<br />    return x + 1;<br />}<br /><br />constexpr bool gt_than_sqrt(int x, int n) {<br />    return x*x &gt; n;<br />}<br /><br />constexpr bool is_prime(int n) {<br />    return gt_than_sqrt(while_loop(2, test_expr{ n }, inc), n);<br />}<br /><br />int main() {<br />    static_assert(is_prime(94418953), "should be prime");<br />    return 0;<br />}<br /></pre><br /><span style="font-size: large;">Logarithmic Growth</span><br /><br />To see that the recursion depth will be <i>O(lg(n))</i> where <i>n</i> is the iteration count, observe that when the last iteration completes, while_loop() will have a recursive depth <i>d</i> and exec() will also produce depth <i>d</i>. Thus, the maximum recursion depth will be <i>2d</i>. At the first level, exec() would have completed 1 iterations, 3 at the second, 7 at the third, and <a href="http://www.codecogs.com/eqnedit.php?latex=2^d-1" target="_blank"><img src="http://latex.codecogs.com/gif.latex?2^d-1" title="2^d-1" /></a> at level <i>d</i>. If <a href="http://www.codecogs.com/eqnedit.php?latex=d%20=%20\left%20\lceil%20lg(n)%20\right%20\rceil" target="_blank"><img src="http://latex.codecogs.com/gif.latex?d = \left \lceil lg(n) \right \rceil" title="d = \left \lceil lg(n) \right \rceil" /></a>, we need to show that<br /><br /><a href="http://www.codecogs.com/eqnedit.php?latex=\sum_{i=1}^{\left%20\lceil%20lg(n)%20\right%20\rceil}2^i-1%20\geq%20n" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\sum_{i=1}^{\left \lceil lg(n) \right \rceil}2^i-1 \geq n" title="\sum_{i=1}^{\left \lceil lg(n) \right \rceil}2^i-1 \geq n" /></a><br /><br />for all sufficiently large&nbsp;<i>n</i>. In that case, the recursion of depth <a href="http://www.codecogs.com/eqnedit.php?latex=\left%20\lceil%20lg(n)%20\right%20\rceil" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\left \lceil lg(n) \right \rceil" title="\left \lceil lg(n) \right \rceil" /></a> can fit more than <i>n</i> iterations. By the use of geometric series formula, the sum becomes&nbsp;<a href="http://www.codecogs.com/eqnedit.php?latex=2^{\left%20\lceil%20lg(n)%20\right%20\rceil@plus;1}-\left%20\lceil%20lg(n)%20\right%20\rceil-2" target="_blank"><img src="http://latex.codecogs.com/gif.latex?2^{\left \lceil lg(n) \right \rceil+1}-\left \lceil lg(n) \right \rceil-2" title="2^{\left \lceil lg(n) \right \rceil+1}-\left \lceil lg(n) \right \rceil-2" /></a>;&nbsp;and since the first term is dominating, we just need to show that&nbsp;<a href="http://www.codecogs.com/eqnedit.php?latex=2^{\left%20\lceil%20lg(n)%20\right%20\rceil@plus;1}\geq%20n" target="_blank"><img src="http://latex.codecogs.com/gif.latex?2^{\left \lceil lg(n) \right \rceil+1}\geq n" title="2^{\left \lceil lg(n) \right \rceil+1}\geq n" /></a>. Note that&nbsp;<a href="http://www.codecogs.com/eqnedit.php?latex=2^{\left%20\lceil%20lg(n)@plus;1%20\right%20\rceil}=2(2^{\left%20\lceil%20lg(n)%20\right%20\rceil})\geq%202n\geq%20n" target="_blank"><img src="http://latex.codecogs.com/gif.latex?2^{\left \lceil lg(n)+1 \right \rceil}=2(2^{\left \lceil lg(n) \right \rceil})\geq 2n\geq n" title="2^{\left \lceil lg(n)+1 \right \rceil}=2(2^{\left \lceil lg(n) \right \rceil})\geq 2n\geq n" /></a>.<br /><br /><span style="font-size: large;">Practical Simplification</span><br /><br />Since our initial goal was to not exceed the compiler recursion limit, we do not actually need truly logarithmic depth. It will suffice to map the loop iterations onto a tree of certain depth. For example, if we choose a depth of 30, we can have up to <a href="http://www.codecogs.com/eqnedit.php?latex=2^{30}=1073741823" target="_blank"><img src="http://latex.codecogs.com/gif.latex?2^{30}=1073741823" title="2^{30}=1073741823" /></a> iterations, more than enough for most practical purposes. In this case, the while_loop() function simplifies to:<br /><br /><pre class="brush: cpp">template &lt;typename T, typename Test, typename Op&gt;<br />constexpr T while_(T init, Test test, Op op) {<br />    return guarded_accumulate(0, (1 &lt;&lt; 30) - 1, init, test, op);<br />}<br /></pre><br />