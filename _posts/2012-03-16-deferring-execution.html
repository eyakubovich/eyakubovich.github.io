---
layout: post
title: Deferring execution
date: '2012-03-16T20:26:00.001-07:00'
author: Eugene Yakubovich
tags:
- Go
- Boost
- C++
- D
- C++11
modified_time: '2012-04-19T10:04:44.860-07:00'
blogger_id: tag:blogger.com,1999:blog-7098284592115366563.post-7194459177623959401
blogger_orig_url: http://dev-perspective.blogspot.com/2012/03/deferring-execution.html
---

Go language has&nbsp;<a href="http://golang.org/doc/go_spec.html#Defer_statements">defer statements</a>&nbsp;which allow for postponing execution of a function or method call until the end of the current function. Similarly, D has&nbsp;<a href="http://dlang.org/statement.html#ScopeGuardStatement">scope guard statements</a>&nbsp;which allow statement execution to be delayed until the end of the scope (optionally specified to only execute under successful or failed scenarios).<br /><br /><table border="0" cellspacing="10"><tbody><tr><td><b>Go</b></td><td><br /></td><td><b>D</b></td></tr><tr><td><pre>lock(l)<br />// unlocking happens before<br />// surrounding function returns<br />defer unlock(l)<br /></pre></td><td><br /></td><td><pre>lock(l);<br />// unlock on leaving the scope<br />scope(exit) unlock(l);<br /></pre></td></tr></tbody></table><br />This is similar to 'finally' statements that are used in languages like Java and Python. In C++, we have our trusty&nbsp;<a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII technique</a>&nbsp;to execute clean up code at the end of scope. But for the cases when that is not convenient, boost provides&nbsp;<a href="http://www.boost.org/doc/libs/1_49_0/libs/scope_exit/doc/html/index.html">ScopeExit</a>&nbsp;library to accomplish something akin to D:<br /><br /><pre class="brush: cpp">lock(l);<br />BOOST_SCOPE_EXIT( (&amp;l) )<br />{<br />    unlock(l);<br />} BOOST_SCOPE_EXIT_END<br /></pre><br />If you look at Boost.ScopeExit source, it is filled with enough macro magic to make your head spin. The upside is that it works with C++03. But with C++11 and lambdas, we can build the same functionality and more with easy to read, macro free code.<br /><br />The basic idea is to put deferred code into a lambda function and then store the lambda in a class that will execute it when it destructs. Let's start with this:<br /><br /><pre class="brush: cpp">template &lt;typename F&gt;<br />struct deferrer {<br />    F fun;<br />    ~deferrer() { fun(); }<br />};<br /><br />template &lt;typename F&gt;<br />deferrer&lt;F&gt; defer(F const&amp; f) {<br />    return deferrer&lt;F&gt;{ f };<br />}<br /></pre>With this simple class (struct for now) and helper function, we can defer code like this:<br /><pre class="brush: cpp">void foo() {<br />    lock_t l;<br />    lock(l);<br />    auto d = defer([&amp;l] { unlock(l); });<br />    // ...<br />}<br /></pre><br />However, there are a number of problems with this code. First, if lambda function throws, we will get a throwing destructor and the program will go to terminate() in those cases when the stack was already being unwound due to an exception. We can either leave things as is and disallow deferred code to throw or surround fun() invokation in try/catch block. Since this problem plaques RAII as well, I'll just resort to the former.<br /><br />Second, and more serious problem, is that deferrer&lt;F&gt; is copyable and since defer() returns the object by value, there will be temporaries that get constructed and destructed. Since the destructor executes our function, our deferred code will get executed multiple times and prematurely! Well, that's the worst case scenario. Most compilers now implement copy elision and so <a href="http://en.wikipedia.org/wiki/Return_value_optimization">RVO</a> will actually not make this scenario appear. But relying on a compiler optimization is a bad practice anyway.<br /><br />You might be saying right now, "wait a minute, this is C++11, shouldn't the return value be moved instead of copied?". Yes, if the move constructor is available. But by defining the destructor, we opted out of move constructor (and move assignment operator) being implicitly defined for us. Remember, the C++ committee tightened the rules regarding when the implicit generation is OK. Dave Abrahams has a nice <a href="http://cpp-next.com/archive/2011/02/w00t-w00t-nix-nix/">post</a> on the topic. BTW, gcc 4.6 still generates the move constructor and I haven't tested the soon to be released 4.7.<br /><br />The best thing to do here is to forbid copying and define a move constructor:<br /><pre class="brush: cpp">template &lt;typename F&gt;<br />class deferrer {<br />    F fun;<br />    bool enabled;<br /><br />public:<br />    deferrer(F const&amp; f) : fun(f), enabled(true) {}<br /><br />    // move constructor<br />    deferrer(deferrer&lt;F&gt;&amp;&amp; rhs) : fun(rhs.fun), enabled(rhs.enabled) {<br />        rhs.enabled = false;<br />    }<br /><br />    // move assignment<br />    deferrer&lt;F&gt;&amp; operator=(deferrer&lt;F&gt;&amp;&amp; rhs) {<br />        if( this != &amp;rhs ) {<br />            fun = rhs.fun;<br />            enabled = rhs.enabled;<br />            rhs.enabled = false;<br />        }<br />        return *this;<br />    }<br /><br />    // no copying<br />    deferrer(deferrer&lt;F&gt; const&amp; ) = delete;<br />    deferrer&lt;F&gt;&amp; operator=(deferrer&lt;F&gt; const&amp;) = delete;<br /><br />    ~deferrer() {<br />        if( enabled )<br />            fun();<br />    }<br /><br />    // add this as a bonus <br />    void cancel() { enabled = false; }<br />};<br /></pre><br />Now let's turn our attention to the case when the deferred action should happen not at the end of lexical scope of where deferment was specified but at the end of the function scope or the end of some other lexical scope. For example:<br /><pre class="brush: cpp">void foo(const char* path, bool cleanup) {<br />    int fd = creat(path, S_IRUSR);<br />    if( cleanup ) {<br />        auto d = defer([path, fd]{<br />            close(fd);<br />            unlink(path);<br />        });<br />    }<br />    else {<br />        auto d = defer([fd]{ close(fd); });<br />    }<br />    // oops, closed and maybe unlinked too early!<br />    // ....<br />}<br /></pre><br />We can fix this by creating another class that we can instantiate in the lexical scope at the end of which we want the deferred action to be executed:<br /><pre class="brush: cpp">void foo(const char* path, bool cleanup) {<br />    deferred d; // deferred action will execute at the end of foo()<br />    int fd = creat(path, S_IRUSR);<br />    if( cleanup ) {<br />        d = defer([path, fd]{<br />            close(fd);<br />            unlink(path);<br />        });<br />    }<br />    else {<br />        d = defer([fd]{ close(fd); });<br />    }<br />    // ....<br />}<br /></pre>To implement such a beast, we'll need to use std::function to type erase the lambda into nullary function:<br /><pre class="brush: cpp">template &lt;typename F&gt;<br />class deferrer {<br />    friend class deferred;<br />    // remainder not changed<br />};<br /><br />class deferred {<br />    std::function&lt;void ()&gt; fun;<br /><br />public:<br />    deferred() = default;<br />    deferred(deferred const&amp;) = delete;<br />    deferred&amp; operator=(deferred const&amp;) = delete;<br /><br />    template &lt;typename F&gt;<br />    deferred(deferrer&lt;F&gt;&amp;&amp; d) {<br />        if( d.enabled ) {<br />            fun = d.fun;<br />            d.enabled = false;<br />        }<br />    }<br /><br />    ~deferred() {<br />        if( fun )<br />            fun();<br />    }<br />};<br /></pre><br /><span style="font-size: large;">Conclusion</span><br /><br />While I think that the time it takes to define an RAII object is well spent, I admit that the occasional use of scope exit facility can be convenient. It is also great to see that lambda functions allow us to implement few simple utility classes that can do what other languages had to provide in the language itself.