---
layout: post
title: Lazy approach to assignment operators
date: '2013-09-03T19:56:00.000-07:00'
author: Eugene Yakubovich
tags:
- C++
- C++11
modified_time: '2013-09-03T19:57:26.316-07:00'
blogger_id: tag:blogger.com,1999:blog-7098284592115366563.post-7315567599340791023
blogger_orig_url: http://dev-perspective.blogspot.com/2013/09/lazy-approach-to-assignment-operators.html
---

Most of the time we don't have to worry about defining copy/move constructors and assignment operators -- the compiler happily generates them for us. Sometimes, however, we must do the dirty work ourselves and code them up manually, often together with the destructor. By hand crafting the assignment operators, we sometimes gain extra efficiency (e.g. std::vector re-using the memory in copy-assignment) but most of the time the code just ends up looking like a copy/paste job of destructor and copy/move constructor.<br /><br />If we're not lazy and define a swap function, we can use the&nbsp;<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Copy-and-swap">copy/swap</a>&nbsp;idiom to get a free pass on the copy-assignment operator. Not so for the move-assignment. <a href="http://efesx.com/2009/09/04/implementing-assignment-operator-using-copy-constructor/">This post</a> from 2009 provides an interesting trick to reuse destructor/copy constructor to implement the copy-assignment without the swap function. Here's the code provided by that post:<br /><br /><pre class="brush: cpp">struct A {<br />&nbsp; &nbsp; A ();<br />&nbsp; &nbsp; A (const A &amp;a);<br />&nbsp; &nbsp; virtual A &amp;operator= (const A &amp;a);<br />&nbsp; &nbsp; virtual ~A ();<br />};<br /><br />A &amp;A::operator= (const A &amp;a) {<br />&nbsp; &nbsp; if (this != &amp;a) {<br />&nbsp; &nbsp; &nbsp; &nbsp; this-&gt;A::~A(); // explicit non-virtual destructor<br />&nbsp; &nbsp; &nbsp; &nbsp; new (this) A(a); // placement new<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return *this;<br />}<br /></pre><br />The author does warn about the downsides of using this trick but I think the concerns are fairly minor. The technique can also be extended for the move-assignment operator:<br /><br /><pre class="brush: cpp">template &lt;typename T, typename U&gt;<br />A &amp;A::operator= (A &amp;&amp;a) {<br />&nbsp; &nbsp; if (this != &amp;a) {<br />&nbsp; &nbsp; &nbsp; &nbsp; this-&gt;A::~A(); // explicit non-virtual destructor<br />&nbsp; &nbsp; &nbsp; &nbsp; new (this) A(std::move(a)); // placement new<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return *this;<br />}<br /></pre><br />And can be generalized into a utility function that can cover both of those uses. The function and its usage is shown below:<br /><br /><pre class="brush: cpp">template &lt;typename T, typename U&gt;<br />T&amp; assign(T* obj, U&amp;&amp; other) {<br />&nbsp; &nbsp; if( obj != &amp;other ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; obj-&gt;T::~T();<br />&nbsp; &nbsp; &nbsp; &nbsp; new (static_cast&lt;void*&gt;(obj)) T(std::forward&lt;U&gt;(other));<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return *obj;<br />}<br /></pre><br /><pre class="brush: cpp">struct A {<br />&nbsp; &nbsp; A ();<br />&nbsp; &nbsp; A (const A&amp; a);<br />&nbsp; &nbsp; A(A&amp;&amp; a);<br />&nbsp; &nbsp; virtual ~A ();<br />&nbsp; &nbsp; A&amp; operator= (const A&amp; a) {<br />&nbsp; &nbsp; &nbsp; &nbsp; return assign(this, a);<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; A&amp; operator=(A&amp;&amp; a) {<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; return assign(this, std::move(a));<br />&nbsp; &nbsp; }<br />};<br /></pre><br />One very nice side affect of this approach is that it becomes possible to create a copy/move assignment operators for those classes that can otherwise only be copy/move constructable. For example, consider: <br /><br /><pre class="brush: cpp">struct X {<br />&nbsp; &nbsp;int&amp; i;<br />};<br /></pre><br />The compiler will generate a copy/move constructor pair but will delete the corresponding assignment operators. You'd be hard pressed to define them yourself as well. But destroy/construct trick allows us to side step such limitations! <br /><br />Note that assign's second argument is a <a href="http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">"universal reference"</a>&nbsp;and will bind to anything. Thus the assign function can actually by used to implement any assignment operator (not just copy/move) as long as the corresponding constructor is available. <br /><br />Now suppose that struct X is located in a third party library and you don't want to modify it to add the assignment operators. By defining a utility class assignable&lt;T&gt;, we can add the desired functionality externally: <br /><br /><pre class="brush: cpp">template &lt;typename T&gt;<br />class assignable : public T {<br />public:<br />&nbsp; &nbsp; using T::T;<br /><br />&nbsp; &nbsp; assignable(T const&amp; other) :<br />&nbsp; &nbsp; &nbsp; &nbsp; T(other) {<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; assignable(T&amp;&amp; other) :<br />&nbsp; &nbsp; &nbsp; &nbsp; T(std::move(other)) {<br />&nbsp; &nbsp; }<br /><br />&nbsp; &nbsp; template &lt;typename U&gt;<br />&nbsp; &nbsp; assignable&amp; operator=(U&amp;&amp; other) {<br />&nbsp; &nbsp; &nbsp; &nbsp; return assign(this, std::forward&lt;U&gt;(other));<br />&nbsp; &nbsp; }<br />};<br /><br />// and usage:<br />struct X {<br />&nbsp; &nbsp; X(int&amp; ii) : i(ii) {}<br />&nbsp; &nbsp; int&amp; i;<br />};<br /><br />int i = 1, j = 2;<br />assignable&lt;X&gt; x(i);<br />x = assignable&lt;X&gt;(j);<br /></pre><pre class="brush: cpp"><br /></pre>This approach makes me wonder if the language should support a way of auto generating the copy/move assignments not member-wise but from destructor and constructor. We could then opt-in to such goodness like this: <br /><br /><pre class="brush: cpp">Foo&amp; operator=(Foo&amp;&amp;) = default(via_constructor);<br />Foo&amp; operator=(Foo const&amp;) = default(via_constructor);<br /></pre><br />The code (along with a work around for compilers not supporting inheritable constructors) is available on <a href="https://github.com/eyakubovich/cxx-sandbox/blob/master/assign.h">GitHub</a>. 