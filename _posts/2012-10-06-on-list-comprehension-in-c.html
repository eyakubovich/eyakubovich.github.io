---
layout: post
title: On List Comprehension in C++
date: '2012-10-06T18:23:00.000-07:00'
author: Eugene Yakubovich
tags:
- Boost
- C++
- C++11
modified_time: '2012-10-07T10:27:52.438-07:00'
blogger_id: tag:blogger.com,1999:blog-7098284592115366563.post-6826180693263620772
blogger_orig_url: http://dev-perspective.blogspot.com/2012/10/on-list-comprehension-in-c.html
---

Many programming languages take inspiration from the language of mathematics and emulate <a href="http://en.wikipedia.org/wiki/Set-builder_notation">Set-builder Notation</a>. Take for instance the following set, specified by the set-builder notation:<br /><br /><a href="http://www.codecogs.com/eqnedit.php?latex=\left%20\{{ "{%" }}20x^{2}%20|%20x%20\in%20\mathbb{N},%20x%20%3E%205%20\right%20\}" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\left \{ x^{2} \mid x \in \mathbb{N}, x &gt; 5 \right \}" title="\left \{ x^{2} \mid x \in \mathbb{N}, x &gt; 5 \right \}" /></a><br /><br /><br /><br />Haskell, for example, has <a href="http://en.wikipedia.org/wiki/List_comprehension#Haskell">List Comprehension</a> syntax which allows for expressing the above set as:<br /><br /><span style="font-family: Courier New, Courier, monospace;">[x^2 | x &lt;- [0..], x &gt; 5]</span><br /><br />C# supports <a href="http://en.wikipedia.org/wiki/Language_Integrated_Query">LINQ</a>, which borrows SQL notation to express the same idea. C++ does not have syntactic support for expressing set-builder notation but numerous attempts by library authors have tried to fill the gap. Take a look at <a href="http://stackoverflow.com/questions/232222/is-there-a-linq-library-for-c">this</a>&nbsp;StackOverflow thread for links to projects emulating LINQ in C++. Others have <a href="http://smellegantcode.wordpress.com/tag/c0x/">noted</a>&nbsp;that Boost.Range can already be used for this task. The following code expresses the aforementioned set (at least for a subset of natural numbers):<br /><br /><pre class="brush: cpp">using namespace boost;<br /><br />auto sq = counting_range(0, 1000)<br />&nbsp; &nbsp; &nbsp; &nbsp; | filtered([](int x) { return x &gt; 5; })<br />&nbsp; &nbsp; &nbsp; &nbsp; | transformed([](int x) { return x*x; });<br /></pre><div><br />There is one place though, where Boost.Range approach falls short. Set-builder notation can be used with more than one variable:<br /><br /></div><a href="http://www.codecogs.com/eqnedit.php?latex=\left%20\{{ "{%" }}20x%20@plus;%20y%20|%20x%20\in%20\mathbb{N},%20y%20\in%20\mathbb{N},%20x^2%20@plus;%20y^2%20%3C%20100%20\right%20\}" target="_blank"><img src="http://latex.codecogs.com/gif.latex?\left \{ x + y \mid x \in \mathbb{N}, y \in \mathbb{N}, x^2 + y^2 &lt; 100 \right \}" title="\left \{ x + y \mid x \in \mathbb{N}, y \in \mathbb{N}, x^2 + y^2 &lt; 100 \right \}" /></a><br /><br />In this case, a&nbsp;<a href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>&nbsp;of the sets is taken and the elements of that product are "filtered" and "transformed". The Range library, however, does not provide a way to generate the Cartesian product. So let's look at what it would take to offer such&nbsp;functionality. This will give us a chance to not only experiment with Boost.Range but also play around with variadic templates.<br /><br />Since we'll be making ample use of C++11's variadic templates, it's important to understand them. If you need a good primer, the best thing is to watch Andrei's Alexandrescu's <a href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Variadic-Templates-are-Funadic">Variadic Templates are Funadic</a>&nbsp;(or at least the first 30 mins of it).<br /><br /><h2>The Goal</h2>Let's begin by looking at what we are after:<br /><pre class="brush: cpp">std::vector&lt;int&gt; xx = { 1, 2, 3 };<br />std::vector&lt;char&gt; yy = { 'a', 'b', 'c' };<br />std::vector&lt;double&gt; zz = { 0.1, 0.2, 0.3 };<br /><br />auto r = cartesian(xx, yy, zz)<br />       | xfiltered([](int x, char y, double z) { return x &gt; 1 &amp;&amp; y &lt; 'c'; })<br />       | xtransformed([](int x, char y, double z) { return x + int(y) + z; });<br /></pre><div>cartesian() function takes any number of ranges and returns a range of std::tuple's. In the example above, cartesian(xx, yy, zz) returns a range of std::tuple&lt;int&amp;, char&amp;, double&amp;&gt; and will have nine elements: (1, 'a', 0.1), (1, 'a', 0.2), (1, 'a', 0.3), (1, 'b', 0.1), and so on. xfiltered() and xtransformed() are analogous to filtered() and transformed() except that they allow the lambda to accept multiple arguments instead of a single tuple. Without them, the code would look like this:</div><pre class="brush: cpp">auto r = cartesian(xx, yy, zz)<br />       | filtered([](std::tuple&lt;int&amp;, char&amp;, double&amp;&gt; x) { return std::get&lt;0&gt;(x) &gt; 1 &amp;&amp; std::get&lt;1&gt;(x) &lt; 'c'; })<br />       | transformed([](std::tuple&lt;int&amp;, char&amp;, double&amp;&gt; x) { return std::get&lt;0&gt;(x) + int(std::get&lt;1&gt;(x)) + std::get&lt;2&gt;(x); });<br /></pre><div><br /><h2>Boost Ranges</h2></div><div>Boost Ranges aim to raise the level of abstraction when dealing with sequences by providing a single object representing an interval. However, unlike ranges proposed by Alexandrescu in <a href="http://www.slideshare.net/rawwell/iteratorsmustgo">Iterators Must Go</a> <a href="http://blip.tv/boostcon/boostcon-2009-keynote-2452140">keynote</a>, Boost Ranges are a leaky abstraction. They leak the underlying iterators by requiring the range to expose them via boost::begin(rng) and boost::end(rng). This requirement will force us to define a cartesian_iterator and demonstrate the downside of the leak. The principal advantage of leaking the iterators though is the ability to&nbsp;inter-operate&nbsp;with existing algorithms designed to work with iterators.<br /><br /></div><div><h2>Getting Started</h2>Before getting into the details of the cartesian_iterator that will do all of the heavy-lifting, let's look at the big picture:<br /><pre class="brush: cpp">using namespace boost;<br /><br />// To be filled in later<br />template &lt;typename... Rs&gt;<br />class cartesian_iterator;<br /><br />// Boost.Range provides iterator_range class which constructs a range<br />// from a begin and end iterator pair<br />template &lt;typename... Rs&gt;<br />using cartesian_range = iterator_range&lt;cartesian_iterator&lt;Rs...&gt;&gt;;<br /><br />// Our "public" function that takes any number of ranges and<br />// constructs a cartesian_range<br />template &lt;typename... Rs&gt;<br />typename cartesian_range&lt;Rs...&gt;::type cartesian(Rs&amp;... rs) {<br />&nbsp; &nbsp; typedef cartesian_iterator&lt;Rs...&gt; iter_t;<br />&nbsp; &nbsp; return cartesian_range&lt;Rs...&gt;(iter_t(rs...), iter_t(rs..., 0));<br />}<br /></pre><br /><div>The first step in defining the cartesian_iterator is to decide what will be its value_type. As I mentioned above, it will be the std::tuple of references to the types of the ranges. The code below defines a meta-function to extract the reference type of a range and then uses it to define the value_type of cartesian_iterator: </div><pre class="brush: cpp">template &lt;typename R&gt;<br />struct range_reference {<br />&nbsp; &nbsp; typedef typename boost::range_iterator&lt;R&gt;::type iter;<br />&nbsp; &nbsp; typedef typename iter::reference type;<br />};<br /><br />template &lt;typename... Rs&gt;<br />struct value_type {<br />&nbsp; &nbsp; typedef std::tuple&lt;<br />&nbsp; &nbsp; &nbsp; &nbsp; typename range_reference&lt;Rs&gt;::type...<br />&nbsp; &nbsp; &gt; type;<br />};<br /></pre><div>To ease the task of writing an iterator, we'll be using Boost.Iterators, in particular&nbsp;<a href="http://www.boost.org/doc/libs/1_51_0/libs/iterator/doc/iterator_facade.html">iterator_facade</a> class. We just have to derive from it and implement 3 functions. Here's what the derivation looks like:</div><pre class="brush: cpp">template &lt;typename... Rs&gt;<br />class cartesian_iterator : public boost::iterator_facade&lt;<br />&nbsp; &nbsp; cartesian_iterator&lt;Rs...&gt;, &nbsp;// pass self per CRTP<br />&nbsp; &nbsp; typename value_type&lt;Rs...&gt;::type, &nbsp;// value_type<br />&nbsp; &nbsp; boost::forward_traversal_tag, &nbsp;// iterator category<br />&nbsp; &nbsp; typename value_type&lt;Rs...&gt;::type &nbsp;// reference -- same as value_type!<br />&gt;<br /></pre><div>Note that the reference type will be std::tuple&lt;...&gt; and not std::tuple&lt;...&gt;&amp;. The reason being is that when dereferencing, we'll return a temporary std::tuple&lt;...&gt; since the cartesian_range is not stored in memory per se. Obviously, returning a temporary from a function with a reference return type is a bad idea.</div><div><br /></div><div>Next stop -- deciding what data members will be needed in the iterator. Consider what happens when asked to generate a cartesian_range over two ranges -- {1, 2} and {'a', 'b'}. We are going to use two iterators, one pointing into each sequence and emulating a nested for-loop. On each iteration we advance the iterator over the&nbsp;{'a', 'b'}. Once the iterator advances past 'b', we reset it back to the beginning to point to 'a' again and advance the iterator over {1, 2}.<br /><br />The analysis leads us to conclude that we will (a) need a tuple of iterators into the underlying ranges and (b) a tuple of references to the underlying ranges for resetting the iterators back to the beginning and comparing with the range ends. This demonstrates a weakness of Boost Ranges: our iterator is forced to keep references to the underlying ranges. Since the cartesian_range has two iterators (begin and end), this approach wastes memory. If the a range was a primitive (as in Alexandrescu's ranges), we could save on the extra references. Back to the code -- data members, constructors and equality check:<br /><br /><pre class="brush: cpp">std::tuple&lt;typename boost::range_iterator&lt;Rs&gt;::type... &gt; iters;<br />std::tuple&lt;Rs&amp;...&gt; ranges;<br /><br />cartesian_iterator() {}<br /><br />// used to construct the begin iterator<br />cartesian_iterator(Rs&amp;... rs) :<br />&nbsp; &nbsp; ranges(rs...),&nbsp;iters(boost::begin(rs)...)&nbsp;{}<br /><br />// used to construct the end iterator<br />cartesian_iterator(Rs&amp;... rs, int) :<br />&nbsp; &nbsp; ranges(rs...),&nbsp;iters(boost::end(rs)...)&nbsp;{}<br /><br />// called by iterator_facade's impl of oprerator==<br />bool equal(cartesian_iterator const&amp; other ) const {<br />&nbsp; &nbsp; return iters == other.iters;<br />}<br /></pre><br /><div>With the easy parts are out of the way, let's tackle the iterator's increment functionality. Remember, we need to simulate the nested for loops but in a functional manner:</div><pre class="brush: cpp">template &lt;size_t N&gt;<br />using const_int = std::integral_constant&lt;size_t, N&gt;;<br /><br />// called by iterator_facade's impl of operator++<br />void increment() {<br />&nbsp; &nbsp; increment(const_int&lt;sizeof...(Rs) - 1&gt;());<br />}<br /><br />// helpers<br />template &lt;size_t N&gt;<br />bool increment(const_int&lt;N&gt;) {<br />&nbsp; &nbsp; if( ++(std::get&lt;N&gt;(iters)) == boost::end(std::get&lt;N&gt;(ranges)) ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; if( !increment(const_int&lt;N-1&gt;()) )<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return false;<br />&nbsp; &nbsp; &nbsp; &nbsp; std::get&lt;N&gt;(iters) = boost::begin(std::get&lt;N&gt;(ranges));<br />&nbsp; &nbsp; }<br />&nbsp; &nbsp; return true;<br />}<br /><br />// base case<br />bool increment(const_int&lt;0&gt;) {<br />&nbsp; &nbsp; return ++(std::get&lt;0&gt;(iters)) != boost::end(std::get&lt;0&gt;(ranges));<br />}<br /></pre><div>For any given iterator (starting with the last one), we increment it and if it reached the end, we recursively call ourselves to increment the previous iterator. If we are not at the very end, we reset the given iterator back to the beginning of the range.<br /><br /></div><div><h2>Function application with a tuple</h2></div><div>The last thing to do is to take care of the dereferencing. Before we proceed though, we need to sidestep and look at a problem that I think will often come up with variadics. I speak of calling a function with the arguments stored in a std::tuple. For example, if I have args of type std::tuple&lt;int, char, double&gt; and I want to call "void foo(int, char, double)" with args' elements. It's trivial to do so in this case -- foo(std::get&lt;0&gt;(args),&nbsp;std::get&lt;1&gt;(args),&nbsp;std::get&lt;2&gt;(args)) -- but less so generically with the number of arguments not fixed. <a href="http://stackoverflow.com/questions/7858817/unpacking-a-tuple-to-call-a-matching-function-pointer">This</a> StackOverflow thread's accepted answer provides the best way of doing so.</div><div><br /></div><div>The main idea is for a tuple of size N to generate a sequence of type seq&lt;0, 1, 2, ..., N-1&gt;. Then call a helper function that will capture the integral sequence in its parameter pack and expand it into many calls to std::get&lt;&gt;:</div><div><br /></div><pre class="brush: cpp">// the sequence type<br />template&lt;size_t...&gt;<br />struct seq { };<br /><br />// meta-function to generate seq&lt;0, 1, ..., N-1&gt;<br />template&lt;size_t N, size_t ...S&gt;<br />struct gens : gens&lt;N-1, N-1, S...&gt; { };<br /><br />template&lt;size_t ...S&gt;<br />struct gens&lt;0, S...&gt; {<br />&nbsp; &nbsp; typedef seq&lt;S...&gt; type;<br />};<br /><br />// accepts a tuple and returns seq&lt;0, 1, ..., N-1&gt;<br />template &lt;typename... Ts&gt;<br />typename gens&lt;sizeof...(Ts)&gt;::type tuple_indices(std::tuple&lt;Ts...&gt; const&amp;) {<br />&nbsp; &nbsp; return typename gens&lt;sizeof...(Ts)&gt;::type();<br />};<br /><br />// helper that captures indices into a parameter pack and invokes f<br />template&lt;typename F, typename Args, size_t ...Indices&gt;<br />auto call_func(F&amp;&amp; f, Args&amp;&amp; args, seq&lt;Indices...&gt;) -&gt; decltype(f(std::get&lt;Indices&gt;(args)...)) {<br />&nbsp; &nbsp; return f(std::get&lt;Indices&gt;(args)...);<br />}<br /><br />// takes function f and tuple args and invokes f with args<br />template &lt;typename F, typename Args&gt;<br />auto invoke(F&amp;&amp; f, Args&amp;&amp; args) -&gt; decltype(call_func(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args), tuple_indices(args))) {<br />&nbsp; &nbsp; return call_func(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args), tuple_indices(args));<br />}<br /></pre><div><br /></div><div>I think this problem will come up so often that invoke() should become part of the Standard Library. But as you'll see in a moment, it is important to understand the technique, since invoke() will not always work for all problems of this type.<br /><br /></div><div><h2>Back to Dereference</h2></div><div>The dereference() function needs to construct a std::tuple out of the references returned by dereferencing each of the iterators. The problem here is subtly different from one solved by invoke() above. First, instead of a function (or callable), we are invoking a constructor (albeit this can by solved by using std::make_tuple). Second, our tuple does not contain values to be invoked with. Rather, each of those values (iters tuple contains iterators) needs to be dereferenced&nbsp;first. Fortunately, the technique still applies:</div><div><br /></div><pre class="brush: cpp">// invoked by iterator_facade's impl of operator*()<br />typename value_type&lt;Rs...&gt;::type dereference() const {<br />&nbsp; &nbsp; return dereference(tuple_indices(iters));<br />}<br /><br />// helper<br />template &lt;size_t... Indices&gt;<br />typename value_type&lt;Rs...&gt;::type dereference(seq&lt;Indices...&gt;) const {<br />&nbsp; &nbsp; typedef typename value_type&lt;Rs...&gt;::type result_t;<br />&nbsp; &nbsp; return result_t(*std::get&lt;Indices&gt;(iters)...);<br />}<br /></pre><div><br /></div><div>We have now implemented all the necessary bits for a Forward Iterator.<br /><br /></div><div><h2>Defining Boost.Range Adaptors</h2></div><div>All that is left is to define xfiltered and xtransformed adaptors. It's a pretty simple process described <a href="http://www.boost.org/doc/libs/1_51_0/libs/range/doc/html/range/reference/extending/method_3/method_3_2.html">here</a>. First, we define a polymorphic functor (expander) that will just call invoke() defined earlier. The rest of the code wraps the user passed function inside the expander and passes it on to filter and transform adaptors. Everything else is&nbsp;just boilerplate specified by the Boost.Range's documentation:</div><div><br /></div><pre class="brush: cpp">template &lt;typename F&gt;<br />struct expander {<br />&nbsp; &nbsp; F f;<br /><br />&nbsp; &nbsp; template &lt;typename... Args&gt;<br />&nbsp; &nbsp; typename std::result_of&lt;F(Args...)&gt;::type operator()(std::tuple&lt;Args...&gt; tup) const {<br />&nbsp; &nbsp; &nbsp; &nbsp; return invoke(f, tup);<br />&nbsp; &nbsp; }<br />};<br /><br />// --- xfiltered ---<br />template&lt; class T &gt;<br />struct xfilter_holder : boost::range_detail::holder&lt;T&gt; {<br />&nbsp; &nbsp; xfilter_holder( T r ) : boost::range_detail::holder&lt;T&gt;(r) { }<br />};<br /><br />template&lt; class InputRng, class Pred &gt;<br />boost::filtered_range&lt;expander&lt;Pred&gt;, const InputRng&gt;<br />operator|( const InputRng&amp; r, const xfilter_holder&lt;Pred&gt;&amp; f ) {<br />&nbsp; &nbsp; return boost::filtered_range&lt;expander&lt;Pred&gt;, const InputRng&gt;( expander&lt;Pred&gt;{f.val}, r );&nbsp;<br />}<br /><br />const boost::range_detail::forwarder&lt;xfilter_holder&gt; xfiltered = boost::range_detail::forwarder&lt;xfilter_holder&gt;();<br /><br />// --- xtransformed---<br />template&lt; class T &gt;<br />struct xtransform_holder : boost::range_detail::holder&lt;T&gt; {<br />&nbsp; &nbsp; xtransform_holder( T r ) : boost::range_detail::holder&lt;T&gt;(r) { }<br />};<br /><br />template&lt; class InputRng, class F &gt;<br />boost::transformed_range&lt;expander&lt;F&gt;, const InputRng&gt;<br />operator|( const InputRng&amp; r, const xtransform_holder&lt;F&gt;&amp; f ) {<br />&nbsp; &nbsp; return boost::transformed_range&lt;expander&lt;F&gt;, const InputRng&gt;( expander&lt;F&gt;{f.val}, r );<br />}<br /><br />const boost::range_detail::forwarder&lt;xtransform_holder&gt; xtransformed = boost::range_detail::forwarder&lt;xtransform_holder&gt;();</pre><div><h2>Conclusion</h2></div><div>Boost.Range provides useful blocks that can be put together to express set-builder notation of one variable. Defining a cartesian_range allows for generalizing the solution to any number of variables. We also saw that the leaky nature of Boost Ranges make it awkward to define some types of ranges/iterators. Variadic templates and std::tuple are great additions to C++ but the Standard Library could benefit from an invoke() function.</div></div></div>