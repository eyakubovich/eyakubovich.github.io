---
layout: post
title: Factory functions and their return types
date: '2014-05-08T14:05:00.001-07:00'
author: Eugene Yakubovich
tags:
- C++
- C++11
modified_time: '2014-05-09T09:13:32.529-07:00'
blogger_id: tag:blogger.com,1999:blog-7098284592115366563.post-4702879272017296776
blogger_orig_url: http://dev-perspective.blogspot.com/2014/05/factory-functions-and-their-return-types.html
---

Suppose we need to write a factory function that constructs a runtime polymorphic object. For the purposes of this post, let's say we want to construct a concrete shape object -- a rectangle, triangle, or an ellipse. Here are our basic declarations:<br /><br /><pre class="brush: cpp">struct shape {<br />&nbsp; &nbsp; virtual ~shape() {}<br />};<br /><br />struct ellipse : shape {<br />&nbsp; &nbsp; ellipse(int rad_a, int rad_b) {}<br />};<br /><br />struct triangle : shape {<br />&nbsp; &nbsp; triangle(int base, int height) {}<br />};<br /><br />struct rectangle : shape {<br />&nbsp; &nbsp; rectangle(int width, int height) {}<br />};<br /></pre><div><br /></div><div>Basic stuff. Now for the factory function:</div><div><br /></div><pre class="brush: cpp">enum class shape_type { ellipse, triangle, rectangle };<br /><br />struct rect {<br />&nbsp; &nbsp; int w, h;<br />};<br /><br />??? make_shape(shape_type type, rect bounds);<br /></pre><div><br /></div><div>What should make_shape return. A pointer to shape, of course, but which kind. Should it be a raw pointer or a smart pointer like std::unique_ptr and std::shared_ptr. C++11 heavily advocates against raw pointers and I completely agree. That leaves us with a unique_ptr or a shared_ptr. I believe that in vast majority of situations there's a single owner of an object so that begs for returning unique_ptr. At least few other people are of the same opinion: <a href="http://stackoverflow.com/questions/13062106/returning-pointer-from-factory">here</a>&nbsp;and <a href="http://herbsutter.com/2013/05/30/gotw-90-solution-factories/">here</a>.</div><div><br /></div><div>The argument goes that a shared_ptr can be constructed from a unique_ptr&amp;&amp; so this will also work just fine for the less common shared ownership cases:</div><div><br /></div><pre class="brush: cpp">std::shared_ptr&lt;shape&gt; s = make_shape(shape_type::ellipse, { 3, 5 });<br /></pre><div><br /></div><div>While that is certainly true, there is a performance problem with this. C++11 encourages us to use std::make_shared&lt;T&gt; to construct shared ownership objects. Most std::make_shared implementations use a single dynamic memory allocation for both the object and the pointer control block (that stores the ref count). Not only does that save on overhead of calling 'new' twice, it also improves the cache locality by keeping the two close.</div><div><br /></div><div>That benefit is clearly lost with conversion from unique_ptr to shared_ptr. I would therefore argue that factory functions should come in two flavors: a unique and a shared kind:</div><div><br /></div><div><pre class="brush: cpp">std::unique_ptr&lt;shape&gt; make_unique_shape(shape_type type, rect bounds);<br />std::shared_ptr&lt;shape&gt; make_shared_shape(shape_type type, rect bounds);<br /></pre><div><br /></div><div>We now have two functions that do almost identical work. To avoid code duplication, we should factor out common behavior, right? Right but it turns out to be trickier than I expected. What we want is a helper function that is parameterized on make_shared or make_unique (or similar till will have it in C++14). The solution I came up with uses good old tag dispatching.</div><div><br /></div><div>First, declare the tags but have them also know their associated smart pointer type:</div><div><br /></div><pre class="brush: cpp">struct shared_ownership {<br />&nbsp; &nbsp; template &lt;typename T&gt; using ptr_t = std::shared_ptr&lt;T&gt;;<br />};<br /><br />struct unique_ownership {<br />&nbsp; &nbsp; template &lt;typename T&gt; using ptr_t = std::unique_ptr&lt;T&gt;;<br />};&nbsp;<br /></pre><div><br />Next, we add two overloads to do the actual construction:</div><div><br /></div><pre class="brush: cpp">template &lt;typename T, typename... Args&gt;<br />std::unique_ptr&lt;T&gt; make_with_ownership(unique_ownership, Args... args) {<br />&nbsp; &nbsp; // until we have make_unique in C+14<br />&nbsp; &nbsp; return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));<br />}<br /></pre><div><br /></div><pre class="brush: cpp">template &lt;typename T, typename... Args&gt;<br />std::shared_ptr&lt;T&gt; make_with_ownership(shared_ownership, Args... args) {<br />&nbsp; &nbsp; return std::make_shared&lt;T&gt;(std::forward&lt;Args&gt;(args)...);<br />}<br /></pre><div><br /></div><div>Finally, we can put it all together to create a generic make_shape along with make_unique_shape and make_shared_shape:</div><div><br /></div><pre class="brush: cpp">template &lt;typename OwnTag&gt;<br />typename OwnTag::template ptr_t&lt;shape&gt; make_shape(shape_type type, rect bounds, OwnTag owntag) {<br />&nbsp; &nbsp; switch( type ) {<br />&nbsp; &nbsp; &nbsp; &nbsp; case shape_type::ellipse:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return make_with_ownership&lt;ellipse&gt;(owntag, bounds.w / 2, bounds.h / 2);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; case shape_type::triangle:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return make_with_ownership&lt;triangle&gt;(owntag, bounds.w, bounds.h);<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; case shape_type::rectangle:<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return make_with_ownership&lt;rectangle&gt;(owntag, bounds.w, bounds.h);<br />&nbsp; &nbsp; }<br />}<br /><br />inline std::unique_ptr&lt;shape&gt; make_unique_shape(shape_type type, rect bounds) {<br />&nbsp; &nbsp; return make_shape(type, bounds, unique_ownership());<br />}<br /><br />inline std::shared_ptr&lt;shape&gt; make_shared_shape(shape_type type, rect bounds) {<br />&nbsp; &nbsp; return make_shape(type, bounds, shared_ownership());<br />}<br /></pre><div><br />If you look at the return type of make_shape, it should make you cringe with disgust. Yeah, no bonus points for elegant syntax here. I also dislike the verbose name make_with_ownership. Nevertheless, I believe having a generic function for both unique and shared construction is extremely valuable. I would love to hear proposals for a better implementation and suggestions for a more concise name.<br /><br /></div><div></div><div>As always, the code is available on <a href="https://github.com/eyakubovich/blog-code/tree/master/factory">GitHub</a>.</div></div>