---
layout: post
title: Iterating over a text file
date: '2012-09-07T13:25:00.001-07:00'
author: Eugene Yakubovich
tags:
- Boost
- C++
- C++11
modified_time: '2013-07-27T10:39:32.000-07:00'
blogger_id: tag:blogger.com,1999:blog-7098284592115366563.post-402001686521747232
blogger_orig_url: http://dev-perspective.blogspot.com/2012/09/iterating-over-text-file.html
---

It's a simple task -- you want iterate over all the lines in a file and perform an action on each one. In Python it's as simple as:<br /><pre class="brush: python">for line in open("somefile.txt"):<br />&nbsp; &nbsp; print line<br /></pre>How about C++11. How hard can it be? <a href="http://stackoverflow.com/questions/2291802/is-there-a-c-iterator-that-can-iterate-over-a-file-line-by-line">This</a> stackoverflow post gives us a starting point. We first define an iterator:<br /><pre class="brush: cpp">struct line_t : std::string {<br />&nbsp; &nbsp; &nbsp;friend std::istream &amp; operator&gt;&gt;(std::istream&amp; is, line_t&amp; line) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return std::getline(is, line);<br />&nbsp; &nbsp; &nbsp;}<br />};<br />typedef std::istream_iterator&lt;line_t&gt; line_iterator;<br /></pre><a href="http://www.boost.org/doc/libs/1_51_0/libs/range/doc/html/index.html">Boost.Range</a>&nbsp;packages a pair of begin/end iterators into a <i>range</i>&nbsp;which makes the code more elegant. It defines all those algorithms found in std namespace in terms of ranges. So we'll give ranges a try and hope it improves our style. Since std::pair of iterators is a valid Boost.Range range, let's define a line_range in terms of that and also a helper function to construct the range:<br /><pre class="brush: cpp">typedef std::pair&lt;line_iterator, line_iterator&gt; line_range;<br /><br />line_range lines(std::ifstream&amp; is) {<br />&nbsp; &nbsp; return line_range(line_iterator(is), line_iterator());<br />}<br /></pre>Now we can use Boost.Range's for_each to iterate over a file:<br /><pre class="brush: cpp">std::ifstream file("somefile.txt");<br />boost::for_each(lines(file), [](std::string const&amp; line) {<br />&nbsp; &nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br />});<br /></pre>Not bad. Not counting the very last line, it's 3 lines of code. One more than Python. Let's see if we can get it down to two lines by constructing the ifstream object as a temporary: <br /><pre class="brush: cpp">boost::for_each(lines(std::ifstream("somefile.txt")), [](std::string const&amp; line) {<br />&nbsp; &nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br />});<br /></pre><pre>g++ -std=c++0x iter.cpp<br />iter.cpp: In function ‘int main()’:<br />iter.cpp:97:54: error: invalid initialization of non-const reference of type ‘std::ifstream&amp; {aka std::basic_ifstream&lt;char&gt;&amp;}’ from an rvalue of type ‘std::ifstream {aka std::basic_ifstream&lt;char&gt;}’<br />iter.cpp:82:12: error: in passing argument 1 of ‘line_range lines(std::ifstream&amp;)’<br /></pre>That doesn't work. Of course -- passing a temporary into a function that takes a non-const reference will not work. Unfortunately we can't change it to a const reference since istream_iterator's constructor takes a non-const reference. Fortunately we can deal with this situation by taking it as an rvalue reference:<br /><pre class="brush: cpp">line_range lines(std::ifstream&amp;&amp; is) {<br />&nbsp; &nbsp; return line_range(line_iterator(is), line_iterator());<br />}<br /></pre>This will happily compile and work but we just broke the previous usage. That is because an rvalue reference won't bind to an lvalue. We can do two things to solve this problem. First is to provide two overloads:<br /><pre class="brush: cpp">line_range lines(std::ifstream&amp; is) {<br />&nbsp; &nbsp; return line_range(line_iterator(is), line_iterator());<br />}<br /><br />line_range lines(std::ifstream&amp;&amp; is) {<br />&nbsp; &nbsp; return lines(is);<br />}<br /></pre>The second overload ends up calling the first one because an rvalue reference is itself an lvalue! See the&nbsp;<a href="http://thbecker.net/articles/rvalue_references/section_01.html">tutorial by Thomas Becker</a> to learn everything you'll ever need about rvalue references. The other way is to use the mechanism employed by std::forward:<br /><pre class="brush: cpp">template &lt;typename S&gt;<br />line_range lines(S&amp;&amp; is) {<br />&nbsp; &nbsp; return line_range(line_iterator(is), line_iterator());<br />}<br /></pre>A call with lvalue will bind S to std::ifstream&amp; and with &amp;&amp; will collapse to just std::ifstream&amp;. A call with rvalue will bind S to std::ifstream and the whole thing will be std::ifstream&amp;&amp;. Again, see Becker's <a href="http://thbecker.net/articles/rvalue_references/section_08.html">Section 8</a> for more detail.<br />Presto! We got two perfectly good ways to make it work with temporaries or not.   <br /><h2>Room for Improvement: Using range-based-for</h2>As much as I love lambdas and functional programming, there is a lot to be said for a good old for loop. And with C++11 we have the new range-based-for (aka foreach). I'd rather write this:  <br /><pre class="brush: cpp">for( auto&amp; line: lines(std::ifstream("somefile.txt")) )<br />&nbsp; &nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br /></pre>In order for the range-based-for to work we must expose begin/end iterators via one of two ways. Either our line_range needs to have begin() and end() methods (just like STL containers) or we need to have free functions with same names such that ADL can pick them up. Since Boost.Range defines such free functions (boost::begin() and boost::end()), all we need to do is dump them into our namespace:  <br /><pre class="brush: cpp">using boost::begin;<br />using boost::end;<br /><br />std::ifstream file("somefile.txt");<br />for( auto&amp; line: lines(file) )<br />&nbsp; &nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br /></pre>This works great but unfortunately this does not (although it compiles):<br /><pre class="brush: cpp">for( auto&amp; line: lines(std::ifstream("somefile.txt")) )<br />&nbsp; &nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br /></pre>The reason being is that the compiler transforms this loop&nbsp;[stmt.ranged/1]&nbsp;into:  <br /><pre class="brush: cpp">auto&amp;&amp; __range = lines(std::ifstream("somefile.txt"));<br />// regular for loop using iterators returned by begin(__range) and end(__range)<br /></pre>lines() returns the instance of line_range by value but its lifetime is extended to that of a the __range reference. However the lifetime of std::ifstream temporary is <i>not</i> extended! It is destroyed before the loop is even started. It's a problem that didn't exist when we were using boost::for_each since the whole iteration was all one statement. See&nbsp;[class.temporary/5] for details.<br />How should we fix it? Since the line_range temporary lives on for the duration of the loop, we need to move the instance of std::ifstream <i>into</i> it. For the cases where std::ifstream is an lvalue rather than a temporary, we can just store a reference to it. Let's get started.  <br /><br />Start off by redefining line_range as a class, ditching the std::pair of iterators:  <br /><pre class="brush: cpp">template &lt;typename T&gt;<br />class line_range {<br />&nbsp; &nbsp; T istr;<br />public:<br />&nbsp; &nbsp; line_range(T&amp;&amp; is) : istr(std::forward&lt;T&gt;(is)) {}<br />&nbsp; &nbsp; line_iterator begin() { return line_iterator(istr); }<br />&nbsp; &nbsp; line_iterator end() { return line_iterator(); }<br />};<br /></pre><br />We need to rig this up so that T=std::ifstream if a temporary is used and T=std::ifstream&amp; otherwise. Well, we know how to this! You did read&nbsp;Becker's&nbsp;<a href="http://thbecker.net/articles/rvalue_references/section_08.html">Section 8</a>, didn't you?!  <br />It's as simple as (albeit syntax is not simple):  <br /><pre class="brush: cpp">template &lt;typename S&gt;<br />auto lines(S&amp;&amp; is) -&gt; decltype(line_range&lt;S&gt;(std::forward&lt;S&gt;(is))) {<br />&nbsp; &nbsp; return line_range&lt;S&gt;(std::forward&lt;S&gt;(is));<br />}<br /></pre>It's an example of the Perfect Forwarding problem -- we just forward rvalueness/lvalueness through to the line_range and end up either moving the object or storing the reference to it.&nbsp;As a very last step, we have to slightly modify the line_range to once again&nbsp;accommodate&nbsp;Boost.Range. Complete code is shown below:<br /><pre class="brush: cpp">#include &lt;iostream&gt;<br />#include &lt;fstream&gt;<br />#include &lt;boost/range/algorithm/for_each.hpp&gt;<br /><br />struct line_t : std::string {<br />&nbsp; &nbsp; &nbsp;friend std::istream &amp; operator&gt;&gt;(std::istream&amp; is, line_t&amp; line) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return std::getline(is, line);<br />&nbsp; &nbsp; &nbsp;}<br />};<br /><br />typedef std::istream_iterator&lt;line_t&gt; line_iterator;<br /><br />template &lt;typename T&gt;<br />class line_range {<br />&nbsp; &nbsp; T istr;<br />&nbsp; &nbsp; line_iterator b;<br /><br />public:<br />&nbsp; &nbsp; typedef line_iterator iterator;<br />&nbsp; &nbsp; typedef line_iterator const_iterator;<br /><br />&nbsp; &nbsp; line_range(T&amp;&amp; is) :<br />&nbsp; &nbsp; &nbsp; &nbsp; istr(std::forward&lt;T&gt;(is)),<br />&nbsp; &nbsp; &nbsp; &nbsp; b(istr)<br />&nbsp; &nbsp; {}<br /><br />&nbsp; &nbsp; line_iterator begin() const { return b; }<br />&nbsp; &nbsp; line_iterator end() const { return line_iterator(); }<br />};<br /><br />template &lt;typename S&gt;<br />auto lines(S&amp;&amp; is) -&gt; decltype(line_range&lt;S&gt;(std::forward&lt;S&gt;(is))) {<br />&nbsp; &nbsp; return line_range&lt;S&gt;(std::forward&lt;S&gt;(is));<br />}<br /><br />int main()<br />{<br />&nbsp; &nbsp; std::ifstream file("somefile.txt");<br />&nbsp; &nbsp; for( auto&amp; line: lines(file) )<br />&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br /><br />&nbsp; &nbsp; for( auto&amp; line: lines(std::ifstream("somefile.txt")) )<br />&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br /><br />&nbsp; &nbsp; std::ifstream file2("somefile.txt");<br />&nbsp; &nbsp; boost::for_each(lines(file2), [](std::string const&amp; line) {<br />&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br />&nbsp; &nbsp; });<br /><br />&nbsp; &nbsp; boost::for_each(lines(std::ifstream("somefile.txt")), [](std::string const&amp; line) {<br />&nbsp; &nbsp; &nbsp; &nbsp; std::cout &lt;&lt; line &lt;&lt; std::endl;<br />&nbsp; &nbsp; });<br /><br />&nbsp; &nbsp; return 0;<br />}<br /></pre>