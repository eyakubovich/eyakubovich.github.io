---
layout: post
title: Recursing a constexpr
date: '2012-02-24T08:55:00.000-08:00'
author: Eugene Yakubovich
tags:
- C++
- C++11
- metaprogramming
modified_time: '2012-04-19T10:04:09.527-07:00'
blogger_id: tag:blogger.com,1999:blog-7098284592115366563.post-2775997256234330012
blogger_orig_url: http://dev-perspective.blogspot.com/2012/02/recursing-constexpr.html
---

While reading "<a href="http://cpptruths.blogspot.com/2011/07/want-speed-use-constexpr-meta.html">Want speed? Use constexpr meta-programming!</a>"&nbsp;blog post, I started thinking about how to reduce the recursion depth of such calculations. After all, using a compiler option to increase the recursion depth limits is not very friendly (gcc sets the limit at 512 by default). But before we get to reducing the depth of something like is_prime_func() from the aforementioned post, it's best to start with something slightly easier.<br /><br />Consider a function to compute the following series:<br /><a href="http://www.codecogs.com/eqnedit.php?latex=f(a,%20n)%20=%20\sum_{i=1}^{n}%20a(i^2)%20=%20a(1^2)%20@plus;%20a(2^2)%20@plus;%20a(3^2)%20@plus;%20\cdots%20@plus;%20a(n^2)" target="_blank"><img src="http://latex.codecogs.com/gif.latex?f(a, n) = \sum_{i=1}^{n} a(i^2) = a(1^2) + a(2^2) + a(3^2) + \cdots + a(n^2)" title="f(a, n) = \sum_{i=1}^{n} a(i^2) = a(1^2) + a(2^2) + a(3^2) + \cdots + a(n^2)" /></a><br /><br />Let's begin by writing it without constexpr to be executed at runtime but keeping in mind that we will later convert it for compile time computation. We can write it as a recursive accumulate function to gain some generality:<br /><br /><pre class="brush: cpp">template &lt;typename Int, typename T, typename BinOp&gt;<br />T accumulate(Int first, Int last, T init, BinOp op) {<br />    return (first &gt;= last) ?<br />        init :<br />        accumulate(first+1, last, op(init, first), op);<br />}<br /><br />int sum_squares(int a, int n) {<br />    return accumulate(1, n+1, 0, [a](int prev, int i) {<br />        return prev + a*i*i;<br />    });<br />}<br /></pre><div><br /></div><div>accumulate's signature is very similar to std::accumulate except that instead of dealing with iterators into a sequence, it operates directly on the integral sequence. The sum_squares function calls accumulate() with a lambda expression that captures 'a'.<br /><br />All is good except that accumulate() will produce a recursion depth equal to the length of the input sequence. We can change it to a logarithmic growth by recursively dividing the sequence into two halves:<br /><br /><pre class="brush: cpp">template &lt;typename Int, typename T, typename BinOp&gt;<br />T accumulate(Int first, Int last, T init, BinOp op) {<br />    return<br />        (first &gt;= last ? init :<br />            (first+1 == last) ?<br />                op(init, first) :<br />                accumulate((first + last) / 2, last,<br />                    accumulate(first, (first + last) / 2, init, op), op));<br />}<br /></pre><br />At this point we should be able to just prefix function signatures with constexpr and get the magic of compile time computation. Let's give it a try:<br /><br /><br /><pre class="brush: cpp">template &lt;typename Int, typename T, typename BinOp&gt;<br />constexpr T accumulate(Int first, Int last, T init, BinOp op) {<br />    return<br />        (first &gt;= last ? init :<br />            (first+1 == last) ?<br />                op(init, first) :<br />                accumulate((first + last) / 2, last,<br />                    accumulate(first, (first + last) / 2, init, op), op));<br />}<br /><br />constexpr int sum_squares(int a, int n) {<br />    return accumulate(1, n+1, 0, [a](int prev, int i) {<br />        return prev + a*i*i;<br />    });<br />}<br /><br />int main() {<br />    static_assert(sum_squares(3, 600) == 216540300, "");<br />    return 0;<br />}</pre></div><div><br /></div><pre>$ g++ -std=c++0x test.cpp<br />test.cpp: In function ‘int sum_squares(int, int)’:<br />test.cpp:17:1: error: ‘constexpr T accumulate(Int, Int, T, BinOp) [with Int = int, T = int, BinOp = sum_squares(int, int)::&lt;lambda(int, int)&gt;]’ is not ‘constexpr’<br />test.cpp: In function ‘int main()’:<br />test.cpp:21:2: error: non-constant condition for static assertion<br />test.cpp:21:34: error: ‘int sum_squares(int, int)’ is not a constexpr function<br /></pre><br />For some mysterious reason, C++11 Standard explicitly forbids lambda expressions from being used in constexpr expressions. So we have to fall back to good old functors:<br /><br /><pre class="brush: cpp">struct add_sq {<br />    int a;<br />    constexpr int operator()(int p, int i) const { return p + a*i*i; }<br />};<br /><br />constexpr int sum_squares(int a, int n) {<br />    return accumulate(1, n+1, 0, add_sq{ a });<br />}<br /></pre><br /><span style="font-size: large;">Generalization to for-loop</span><br /><br />It is interesting to note that our accumulate() function can work for arbitrary for-loops of the form: <br /><pre>for( int i = start; i &lt; end; i++ )<br />    body;<br /></pre>To see that, observe that a loop starts with some initial state and then mutates it on every iteration in the body of the loop. Functionally, we can view this mutation as applying an operation of two arguments, an old state and iteration index, to produce the new state. This is precisely what our accumulate function does. Of course, the state might encompass more than just a scalar and we would need a composite type to hold the individual elements. It would be great if std::tuple could work with constexpr but since it doesn't, it's easy enough to define a struct to hold the necessary state.<br /><span style="font-size: large;"><br /></span><br /><span style="font-size: large;">Conclusion</span><br /><br />As we have seen, it is&nbsp;straightforward&nbsp;to convert a recursive function with linear depth into one with logarithmic depth if the number of recursions is known at the point of its invocation. This makes it easy to convert a classic for-loop into recursive form with manageable depth. Next time we'll look at how to convert a while-loop, where the number of iterations is not initially known, into logarithmic depth recursion and in the process define the promised is_prime(n) capable of dealing with very large numbers.