---
layout: post
title: Fun with Intel TBB and Boost.Proto
date: '2012-07-14T10:06:00.001-07:00'
author: Eugene Yakubovich
tags:
- Boost
- TBB
- C++
- C++11
modified_time: '2012-07-20T10:07:08.293-07:00'
thumbnail: http://4.bp.blogspot.com/-dsa-CMbUN48/T_3z5lbUQnI/AAAAAAAAAAg/I6nLVlWO98M/s72-c/dep_graph.jpg
blogger_id: tag:blogger.com,1999:blog-7098284592115366563.post-6478579165225151476
blogger_orig_url: http://dev-perspective.blogspot.com/2012/07/fun-with-intel-tbb-and-boostproto.html
---

<h2>                      Intel Threading Building Blocks</h2>As the hardware engineers cram more and more cores into the processors, software engineers are left to ponder about how to best exploit these new capabilities. Intel offers an open source C++ library they call Threading Building Blocks (TBB). Akin to competing solutions (OpenMP, GCD, PPL), the library allows the developer to break up the computation into bite size pieces called tasks. A task also has a successor (or parent) task which makes it possible to express a relationship describing who should run before whom. The library runtime then takes care of scheduling the tasks onto the physical threads. It is, however, error prone and&nbsp;inconvenient&nbsp;to program using the tasks. Thankfully, much of the programming can be expressed via higher level abstractions (especially those involving fork-join parallelism). For example, parallel_for function allows for using multiple threads to execute the iterations of the loop. Another example is parallel_pipeline function which allows for expressing pipes-and-filters kind of parallelism.<br /><br />TBB also has a facility called a Flow Graph. Designed for those situations when it is best to express the concurrency as a directed graph of&nbsp;dependencies between message emitting nodes, Flow Graph stands almost like a separate library within the library. Let's take a look at an <a href="http://threadingbuildingblocks.org/docs/help/reference/flow_graph/dependency_flow_graph_example.htm">example</a> from TBB's online reference. In this example, every node will print its name after it receives a completion message from the node that it depends on. Here's the dependency graph:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-dsa-CMbUN48/T_3z5lbUQnI/AAAAAAAAAAg/I6nLVlWO98M/s1600/dep_graph.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="320" src="http://4.bp.blogspot.com/-dsa-CMbUN48/T_3z5lbUQnI/AAAAAAAAAAg/I6nLVlWO98M/s320/dep_graph.jpg" width="194" /></a></div><div class="separator" style="clear: both; text-align: left;">And the corresponding code:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><pre class="brush: cpp">#include &lt;cstdio&gt;<br />#include "tbb/flow_graph.h"<br /><br />using namespace tbb::flow;<br /><br />struct body {<br />    std::string my_name;<br />    body( const char *name ) : my_name(name) {}<br />    void operator()( continue_msg ) const {<br />        std::printf("%s\n", my_name.c_str());<br />    }<br />};<br /><br />int main() {<br />    graph g;<br /><br />    broadcast_node&lt; continue_msg &gt; start;<br />    continue_node&lt;continue_msg&gt; a( g, body("A"));<br />    continue_node&lt;continue_msg&gt; b( g, body("B"));<br />    continue_node&lt;continue_msg&gt; c( g, body("C"));<br />    continue_node&lt;continue_msg&gt; d( g, body("D"));<br />    continue_node&lt;continue_msg&gt; e( g, body("E"));<br /><br />    make_edge( start, a );<br />    make_edge( start, b );<br />    make_edge( a, c );<br />    make_edge( b, c );<br />    make_edge( c, d );<br />    make_edge( a, e );<br /><br />    for (int i = 0; i &lt; 3; ++i ) {<br />        start.try_put( continue_msg() );<br />        g.wait_for_all();<br />    }<br /><br />    return 0;<br />}<br /></pre><br />The trouble with the code above is that the graph definition is not declarative. Looking at the series of make_edge calls, it is very hard to visualize the graph. I wanted to see if the situation could be improved...<br /><h2>                      Boost.Proto</h2>I first encountered Boost.Proto at the&nbsp;Extraordinary C++ conference in 2007. Eric Niebler, the author of the library, gave a presentation to an awestruck audience where he took C++ metaprogramming to a level not seen before. In 2010, Eric wrote a series (<a href="http://cpp-next.com/archive/2010/08/expressive-c-introduction/">1</a>, <a href="http://cpp-next.com/archive/2010/09/expressive-c-playing-with-syntax/">2</a>, <a href="http://cpp-next.com/archive/2010/09/expressive-c-why-template-errors-suck-and-what-you-can-do-about-it/">3</a>, <a href="http://cpp-next.com/archive/2010/10/expressive-c-expression-extension-part-one/">4</a>, <a href="http://cpp-next.com/archive/2010/10/expressive-c-expression-extension-part-two/">5</a>, <a href="http://cpp-next.com/archive/2010/11/expressive-c-fun-with-function-composition/">6</a>, <a href="http://cpp-next.com/archive/2010/11/expressive-c-trouble-with-tuples/">7</a>, <a href="http://cpp-next.com/archive/2011/01/expressive-c-expression-optimization/">8</a>) of articles on the subject that were published on <a href="http://cpp-next.com/">C++Next</a> blog. Through this wonderful series, I was finally able to start wrapping my head around Boost.Proto. The library is actually designed for library writers, more specifically those that are interested in developing an&nbsp;embeddable&nbsp;<a href="http://en.wikipedia.org/wiki/Domain_specific_language">DSL</a>&nbsp;inside C++ programs. I am not going try to give a tutorial of Boost.Proto in this post. If you have not yet done so, I highly recommend reading the aforementioned articles. What I hope to do is document my experience of using Boost.Proto for this&nbsp;exercise.<br /><h2>                      Intel TBB meets Boost.Proto</h2>To make the TBB's flow graph construction more declarative, let's create an EDSL for this task. Ideally the syntax would be as close to the picture of a graph as possible but that turned out to be difficult. Let's start with a simple case of few nodes in a row:<br /><br /><a href="http://2.bp.blogspot.com/-dyk4ZjdmZ2w/UAC0K_s-MZI/AAAAAAAAACc/lzNqrQ_YeKM/s1600/graph1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-dyk4ZjdmZ2w/UAC0K_s-MZI/AAAAAAAAACc/lzNqrQ_YeKM/s1600/graph1.png" /></a><br />In the EDSL we will write this as&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">a &gt; b &gt; c</span>. Next, let's look at graphs where a node has more than one edge coming out of it or going into it: <br /><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-3Ta291FM8BI/UAC2ptBOTqI/AAAAAAAAADE/20Mj0eD-oUc/s1600/graph2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-3Ta291FM8BI/UAC2ptBOTqI/AAAAAAAAADE/20Mj0eD-oUc/s1600/graph2.png" /></a>&nbsp;<a href="http://3.bp.blogspot.com/-8hKPmpIg7Po/UAC2vVV02jI/AAAAAAAAADM/WblwtXmA0Gs/s1600/graph3.png" imageanchor="1" style="background-color: white; margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-8hKPmpIg7Po/UAC2vVV02jI/AAAAAAAAADM/WblwtXmA0Gs/s1600/graph3.png" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><br /><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">We will write the left graph as <span style="font-family: 'Courier New', Courier, monospace;">a &gt; (b + c)</span> and the right one as <span style="font-family: 'Courier New', Courier, monospace;">(a + b) &gt; c</span>. Since when I see graphs like this, I tell to myself "a goes to b and c" and "a and b go to c", this syntax seems reasonable. And since in C++ the addition has higher precedence than greater operator, the parenthesis can be dropped: <span style="font-family: 'Courier New', Courier, monospace;">a &gt; b + c</span> and <span style="font-family: 'Courier New', Courier, monospace;">a + b &gt; c</span>.&nbsp;Let's use this syntax to express the graph in the original example:&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">start &gt; (a &gt; e + c)&nbsp;</span><span style="font-family: 'Courier New', Courier, monospace;">+ (b &gt; c &gt; d)</span>.</div><h2>                      The Grammar</h2>As I started working on defining a grammar for this mini language, I first defined it on paper using EBNF notation much like I would do if I was going to use yacc: <br /><span style="font-family: 'Courier New', Courier, monospace;">expr ::= expr "&gt;" group | group</span><br /><div><span style="font-family: 'Courier New', Courier, monospace;">group ::= group "+" node |&nbsp;"(" expr ")" | node</span></div><div><span style="font-family: 'Courier New', Courier, monospace;">node ::=&nbsp;broadcast_node |&nbsp;continue_node</span></div><div><br /></div><div>After a little fumbling however, I realized &nbsp;that Proto grammars can be much simpler. Since Proto expressions are C++ expressions, one does not have to worry about introducing parenthesis into the grammar nor trying to build operator precedence and associativity into it. Thus the grammar actually becomes:</div><div><br /></div><div><span style="font-family: 'Courier New', Courier, monospace;">expr ::= expr "&gt;" expr</span></div><div><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp;| expr "+" expr</span></div><div><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp;| broadcast_node</span></div><div><span style="font-family: 'Courier New', Courier, monospace;">&nbsp; &nbsp; &nbsp; &nbsp;| continue_node</span></div><div><br /></div><div>A grammar like this would usually be&nbsp;ambiguous&nbsp;as it would be unclear how parse a &gt; b &gt; c, for example. But since C++ dictates the operator rules for us, there is no such ambiguity with Proto grammars! Written in Proto (transforms replaced with ellipses for now), it becomes:</div><div><br /></div><pre class="brush: cpp">namespace flow = tbb::flow;<br />namespace proto = boost::proto;<br />typedef flow::broadcast_node&lt;flow::continue_msg&gt; bcast_node;<br />typedef flow::continue_node&lt;flow::continue_msg&gt; cont_node;<br />typedef proto::literal&lt;bcast_node&gt; bcast;<br />typedef proto::literal&lt;cont_node&gt; cont;<br /><br />struct grammar<br />    : proto::or_&lt;<br />        proto::when&lt;proto::plus&lt;grammar, grammar&gt;, ...&gt;,<br />        proto::when&lt;proto::greater&lt;grammar, grammar&gt;, ...&gt;,<br />        proto::when&lt;bcast, ...&gt;,<br />        proto::when&lt;cont, ...&gt;<br />    &gt;<br />{};<br /></pre><br /><h2>           The Transforms</h2>With the grammar in place, it's time to make it actually do stuff. We need to put in semantic actions, or transforms as Proto calls it, next to each grammar rule. In TBB, each node is both a sender and receiver of messages (and is derived from sender&lt;T&gt; and receiver&lt;T&gt;). As we combine the nodes together using the two operators, we produce a compound node which has some of the nodes inside of it acting as its senders and some as receivers. For example, suppose we have an expression <span style="font-family: 'Courier New', Courier, monospace;">(a &gt; b) &gt; (c &gt; d &gt; e)</span> and we have independently build up two compound nodes,<span style="font-family: 'Courier New', Courier, monospace;"> (a &gt; b)</span> and <span style="font-family: 'Courier New', Courier, monospace;">(c &gt; d &gt; e)</span>. We now join the two using the &gt; operator. The &gt; operator splices together the left-hand's senders with right-hand's receivers. In the diagrams below, the box &nbsp;represents the compound node, the receivers are colored blue, the senders are colored red and nodes acting as both receivers and senders are colored purple. For the example above, the following diagram illustrates the before and after the splice. Note that while 'a' is sending messages to 'b', it is actually the receiver of the compound node.<br /><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-_eDA9vfaGPU/UAC5rETztcI/AAAAAAAAADY/yUJeYGKrEVA/s1600/graph4.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-_eDA9vfaGPU/UAC5rETztcI/AAAAAAAAADY/yUJeYGKrEVA/s1600/graph4.png" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;">The + operator joins the two compound nodes by combining the left-hand's receivers with right-hand's receivers and left-hand's senders with right-hand's senders. Again, suppose for the expression <span style="font-family: 'Courier New', Courier, monospace;">(a &gt; b) + (c + d)</span> we are joining <span style="font-family: 'Courier New', Courier, monospace;">(a &gt; b)</span> with <span style="font-family: 'Courier New', Courier, monospace;">(c + d)</span>. The following diagram shows the before and after:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-K80SPTF7ljE/UAC8mS5xJRI/AAAAAAAAADk/MKFlOTgPjsw/s1600/graph5.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-K80SPTF7ljE/UAC8mS5xJRI/AAAAAAAAADk/MKFlOTgPjsw/s1600/graph5.png" /></a></div><div class="separator" style="clear: both; text-align: left;"><br /></div><br />Finally, let's go back to the &gt; operator for the case when there are multiple senders being spliced to multiple receivers. In that case we splice each of the lefthand's senders to each of the right-hand's receivers. Thus, executing &gt; operator on expressions <span style="font-family: 'Courier New', Courier, monospace;">(a + b)</span> and <span style="font-family: 'Courier New', Courier, monospace;">(c + d + e)</span> results in the following graph:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-KRvai_S72P0/UAC9N6V76FI/AAAAAAAAADs/9Ha9CXoaIzA/s1600/graph6.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-KRvai_S72P0/UAC9N6V76FI/AAAAAAAAADs/9Ha9CXoaIzA/s1600/graph6.png" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;">We now have all the pieces to start looking at code. Here are some typedefs:</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;"></div><div class="separator" style="clear: both;"></div><pre class="brush: cpp">typedef std::set&lt;flow::sender&lt;flow::continue_msg&gt;*&gt; sender_set;<br />typedef std::set&lt;flow::receiver&lt;flow::continue_msg&gt;*&gt; receiver_set;<br />typedef std::tuple&lt;sender_set, receiver_set&gt; compound_node;<br /></pre><br />Next up is the easiest of the transforms. When we encounter the terminals, broadcast_node or continue_node, we make a compound_node that only has that node inside of it:<br /><br /><pre class="brush: cpp">struct make_compound_node : proto::callable<br />    typedef compound_node result_type;<br /><br />    compound_node operator()(flow::sender&lt;flow::continue_msg&gt;&amp; s, flow::receiver&lt;flow::continue_msg&gt;&amp; r) {<br />        return compound_node({&amp;s}, {&amp;r});<br />    }<br />};<br /><br />struct grammar<br />    : proto::or_&lt;<br />        proto::when&lt;proto::plus&lt;grammar, grammar&gt;, ...&gt;,<br />        proto::when&lt;proto::greater&lt;grammar, grammar&gt;, ...&gt;,<br />        proto::when&lt;bcast, make_compound_node(proto::_value, proto::_value)&gt;,<br />        proto::when&lt;cont, make_compound_node(proto::_value, proto::_value)&gt;<br />&gt;<br />{};<br /></pre><br />Next, we take care of + operator. Remember, we just need to join the two senders' sets into one and do the same for the receivers' sets:<br /><br /><pre class="brush: cpp">struct join : proto::callable {<br />    typedef compound_node result_type;<br />    compound_node operator()(compound_node left, compound_node right) const {<br />        sender_set&amp; senders = std::get&lt;0&gt;(left);<br />        senders.insert(std::get&lt;0&gt;(right).begin(), std::get&lt;0&gt;(right).end());<br /><br />        receiver_set&amp; receivers = std::get&lt;1&gt;(left);<br />        receivers.insert(std::get&lt;1&gt;(right).begin(), std::get&lt;1&gt;(right).end());<br /><br />        return compound_node(std::move(senders), std::move(receivers));<br />    };<br />};<br /><br />struct grammar<br />    : proto::or_&lt;<br />        proto::when&lt;proto::plus&lt;grammar, grammar&gt;, join(grammar(proto::_left), grammar(proto::_right))&gt;,<br />        proto::when&lt;proto::greater&lt;grammar, grammar&gt;, ...&gt;,<br />        proto::when&lt;bcast, make_compound_node(proto::_value, proto::_value)&gt;,<br />        proto::when&lt;cont, make_compound_node(proto::_value, proto::_value)&gt;<br />&gt;<br />{};<br /></pre><br />And finally the &gt; operator:<br /><br /><pre class="brush: cpp">struct splice : proto::callable {<br />    typedef compound_node result_type;<br /><br />    compound_node operator()(compound_node left, compound_node right) const {<br />        for( auto s: std::get&lt;0&gt;(left) )<br />            for( auto r: std::get&lt;1&gt;(right) )<br />                flow::make_edge(*s, *r);<br /><br />        sender_set&amp; senders = std::get&lt;0&gt;(right);<br />        receiver_set&amp; receivers = std::get&lt;1&gt;(left);<br /><br />        return compound_node(std::move(senders), std::move(receivers));<br />    }<br />};<br /><br />struct grammar<br />    : proto::or_&lt;<br />        proto::when&lt;proto::plus&lt;grammar, grammar&gt;, join(grammar(proto::_left), grammar(proto::_right))&gt;,<br />        proto::when&lt;proto::greater&lt;grammar, grammar&gt;, splice(grammar(proto::_left), grammar(proto::_right))&gt;,<br />        proto::when&lt;bcast, make_compound_node(proto::_value, proto::_value)&gt;,<br />        proto::when&lt;cont, make_compound_node(proto::_value, proto::_value)&gt;<br />&gt;<br />{};</pre><br />The only thing that is left is main() demonstrating the usage:<br /><br /><pre class="brush: cpp">int main() {<br /><br />    flow::graph g;<br /><br />    bcast start(g);<br />    cont a = cont_node( g, body("A"));<br />    cont b = cont_node( g, body("B"));<br />    cont c = cont_node( g, body("C"));<br />    cont d = cont_node( g, body("D"));<br />    cont e = cont_node( g, body("E"));<br /><br />    auto expr =<br />        start &gt; (a &gt; e + c)<br />              + (b &gt; c &gt; d);<br /><br />    grammar()(expr);<br /><br />    proto::value(start).try_put( flow::continue_msg() );<br />    g.wait_for_all();<br /><br />    return 0;<br />}<br /></pre><br /><i>A big thanks goes to Neil Groves for reviewing this article.</i>