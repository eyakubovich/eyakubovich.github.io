---
layout: post
title: More fun with Intel TBB and Boost.Proto (and Boost.Fusion)
date: '2012-07-22T09:47:00.000-07:00'
author: Eugene Yakubovich
tags:
- Boost
- TBB
- C++
- C++11
- metaprogramming
modified_time: '2012-07-22T09:47:43.970-07:00'
blogger_id: tag:blogger.com,1999:blog-7098284592115366563.post-8973001122185779543
blogger_orig_url: http://dev-perspective.blogspot.com/2012/07/more-fun-with-intel-tbb-and-boostproto.html
---

In my last <a href="{{ site.baseurl }}{% post_url 2012-07-14-fun-with-intel-tbb-and-boostproto %}">post</a>, we developed an EDSL for specifying TBB Flow Graph structure with the help of Boost.Proto. Instead of writing a series of tbb::flow::make_edge calls, we can use a little language to help us be more declarative. In the process, however, we lost some of the runtime&nbsp;efficiency. Instead of just invoking make_edge() a number of times, our solution uses loops and temporary data structures (e.g. std::set) which introduce runtime overhead. In this post, we will look at how to modify what we did last time to create a meta-program that will enable us to remove the&nbsp;unnecessary runtime overhead.<br /><div><br /></div><div><h2>Boost.Fusion</h2></div><div><a href="http://www.boost.org/libs/fusion/" style="background-color: white;">Fusion</a><span style="background-color: white;"> library sits somewhere between </span><a href="http://www.boost.org/libs/mpl/" style="background-color: white;">Boost.MPL</a><span style="background-color: white;"> and STL. Like MPL, it provides&nbsp;heterogeneous&nbsp;data structures but&nbsp;</span><span style="background-color: white;">unlike MPL </span><span style="background-color: white;">it is able to operate at runtime. It also is a great tool for certain meta-programming tasks. For example, suppose we wanted to generate code that would invoke foo() multiple times, each with a different value (and maybe type). With Fusion, it is as easy as putting those values into a fusion::vector and then calling fusion::for_each() with the vector and a polymorphic functor:</span></div><pre class="brush: cpp">void foo(int);<br />void foo(double);<br /><br />struct call_foo {<br />    template &lt;typename T&gt;<br />    void operator()(T x) const {<br />        foo(x);<br />    }<br />};<br /><br />int main() {<br />    boost::fusion::vector&lt;int, double, int&gt; v(1, 2.3, 4);<br />    boost::fusion::for_each(v, call_foo());<br />    return 0;<br />}<br /></pre><br />Once the program is compiled with optimizations enabled, all that remains are just foo() invocations (I ran the output generated via -s flag through c++filt to demangle the names):<br /><pre class="brush: plain">main:                          # @main<br />    .cfi_startproc<br /># BB#0:<br />    pushq %rax<br />.Ltmp1:<br />    .cfi_def_cfa_offset 16<br />    movl $1, %edi<br />    callq foo(int)<br />    movsd .LCPI0_0(%rip), %xmm0<br />    callq foo(double)<br />    movl $4, %edi<br />    callq foo(int)<br />    xorl %eax, %eax<br />    popq %rdx<br />    ret<br /></pre><div><br /></div><div>Since what we are trying to do is generate a bunch of make_edge() calls, this seems like exactly what we need.</div><div><br /><h2>Putting it all together</h2>The basic idea is very simple. Replace the use of std::set with boost::fusion::vector when keeping track of senders and receivers in a compound node. We begin by re-defining compound_node to bundle up two fusion vectors. I replaced the use of std::tuple with a struct to make the code more readable and also added a utility function to make the construction easier:<br /><pre class="brush: cpp">template &lt;typename Senders, typename Receivers&gt;<br />struct compound_node {<br />    typedef Senders senders_t;<br />    typedef Receivers receivers_t;<br /><br />    senders_t senders;<br />    receivers_t receivers;<br />};<br /><br />template &lt;typename S, typename R&gt;<br />compound_node&lt;S, R&gt; mk_compound_node(S s, R r) {<br />    return compound_node&lt;S, R&gt;{s, r};<br />}<br /></pre></div><br />Now it's time to modify the make_compound_node transform that is invoked by Proto everytime it meets a terminal:<br /><pre class="brush: cpp">struct make_compound_node : proto::callable {<br />    typedef compound_node&lt;<br />        fusion::vector&lt;flow::sender&lt;flow::continue_msg&gt; *&gt;,<br />        fusion::vector&lt;flow::receiver&lt;flow::continue_msg&gt; *&gt;<br />    &gt; result_type;<br /><br />    result_type operator()(flow::sender&lt;flow::continue_msg&gt;&amp; s, flow::receiver&lt;flow::continue_msg&gt;&amp; r) {<br />        return mk_compound_node(<br />            fusion::vector&lt;flow::sender&lt;flow::continue_msg&gt; *&gt;(&amp;s),<br />            fusion::vector&lt;flow::receiver&lt;flow::continue_msg&gt; *&gt;(&amp;r)<br />        );<br />    }<br />};<br /></pre><br />Next up is the join transform that is applied to process the + operator. Recall that all it has to do is create a new compound node by joining the senders and receivers of the left and right hand sides. To join two Fusion vectors, we use fusion::join function.&nbsp;Unfortunately, it returns not a new vector but a view which contains references to the original sequences it was asked to join. Because we pass everything by value and have tons of temporaries, this is a recipe for disaster. So we force Fusion to create a new vector by passing the result of join to fusion::as_vector. The messy part turns out to be the return type. Remember, Proto transforms have to comply with <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1454.html">(TR1/C++11) result_of protocol</a>. While previously we got away by using the simple method of typedef'ing a result_type, this time our return type depends on the types of&nbsp;arguments. We have to define a meta-function by specializing the result&lt;Sig&gt; struct. Luckily, Fusion library also supports a uniform way of computing result types of its functions (albeit slightly different from the standard approach). All of its functions have a meta-function with the same name in the fusion::result_of namespace.<br /><pre class="brush: cpp">struct join : proto::callable {<br />&nbsp; &nbsp; template &lt;typename Sig&gt;<br />&nbsp; &nbsp; struct result;<br /><br />&nbsp; &nbsp; template &lt;typename This, typename LeftNode, typename RightNode&gt;<br />&nbsp; &nbsp; struct result&lt;This(LeftNode, RightNode)&gt; {<br />&nbsp; &nbsp; &nbsp; &nbsp; typedef typename LeftNode::senders_t left_senders_t;<br />&nbsp; &nbsp; &nbsp; &nbsp; typedef typename LeftNode::receivers_t left_receivers_t;<br />&nbsp; &nbsp; &nbsp; &nbsp; typedef typename RightNode::senders_t right_senders_t;<br />&nbsp; &nbsp; &nbsp; &nbsp; typedef typename RightNode::receivers_t right_receivers_t;<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; typedef compound_node&lt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typename fusion::result_of::as_vector&lt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typename fusion::result_of::join&lt;left_senders_t const, right_senders_t const&gt;::type<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;::type,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typename fusion::result_of::as_vector&lt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typename fusion::result_of::join&lt;left_receivers_t const, right_receivers_t const&gt;::type<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &gt;::type<br />&nbsp; &nbsp; &nbsp; &nbsp; &gt; type;<br />&nbsp; &nbsp; };<br /><br />&nbsp; &nbsp; template &lt;typename LeftNode, typename RightNode&gt;<br />&nbsp; &nbsp; typename result&lt;join(LeftNode, RightNode)&gt;::type operator()(LeftNode left, RightNode right) const {<br />&nbsp; &nbsp; &nbsp; &nbsp; return mk_compound_node(<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fusion::as_vector(fusion::join(left.senders, right.senders)),<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fusion::as_vector(fusion::join(left.receivers, right.receivers))<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );<br />&nbsp; &nbsp; };<br />};<br /></pre><br /><div>Finally we get to the meat of the problem -- implementing splice transform where actual make_edge calls are made. Just like in the join transform above, we need to adhere to result_of protocol using struct specialization. We also need to execute the double for loop: the outer loop iterates over the left-hand's senders and the inner one over the right-hand receivers. But of course we'll use fusion::for_each() twice to do the looping. We are lucky that the fusion::vectors contain&nbsp;homogeneous types -- they are all either flow::sender&lt;continue_msg&gt; or flow::receiver&lt;continue_msg&gt;. This makes it possible to use C++11 lambdas and keep everything in one place.<br /><pre class="brush: cpp">struct splice : proto::callable {<br />&nbsp; &nbsp; template &lt;typename Sig&gt;<br />&nbsp; &nbsp; struct result;<br /><br />&nbsp; &nbsp; template &lt;typename This, typename LeftNode, typename RightNode&gt;<br />&nbsp; &nbsp; struct result&lt;This(LeftNode, RightNode)&gt; {<br />&nbsp; &nbsp; &nbsp; &nbsp; typedef compound_node&lt;<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typename RightNode::senders_t,<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; typename LeftNode::receivers_t<br />&nbsp; &nbsp; &nbsp; &nbsp; &gt; type;<br />&nbsp; &nbsp; };<br /><br />&nbsp; &nbsp; template &lt;typename LeftNode, typename RightNode&gt;<br />&nbsp; &nbsp; typename result&lt;splice(LeftNode, RightNode)&gt;::type operator()(LeftNode left, RightNode right) const {<br />&nbsp; &nbsp; &nbsp; &nbsp; fusion::for_each(left.senders, [&amp;](flow::sender&lt;flow::continue_msg&gt;* s) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fusion::for_each(right.receivers, [=](flow::receiver&lt;flow::continue_msg&gt;* r) {<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flow::make_edge(*s, *r);<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; });<br />&nbsp; &nbsp; &nbsp; &nbsp; });<br /><br />&nbsp; &nbsp; &nbsp; &nbsp; return mk_compound_node(right.senders, left.receivers);<br />&nbsp; &nbsp; }<br />};<br /></pre><br />Note that no changes were necessary to the grammar nor, of course, main(). To verify that we reached our goal, let's check out the&nbsp;disassembly. Since flow::make_edge is inline function, I temporarily declared a make_edge() in the global namespace with the matching signature and used that instead. And voilà:<br /><pre class="brush: plain">&nbsp; &nbsp; leaq &nbsp; &nbsp;560(%rsp), %rsi<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;344(%rsp), %rdi<br />.LEHB53:<br />&nbsp; &nbsp; call &nbsp; &nbsp;make_edge(tbb::flow::interface6::sender&lt;tbb::flow::interface6::continue_msg&gt;&amp;, tbb::flow::interface6::receiver&lt;tbb::flow::interface6::continue_msg&gt;&amp;)<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;816(%rsp), %rsi<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;600(%rsp), %rdi<br />&nbsp; &nbsp; call &nbsp; &nbsp;make_edge(tbb::flow::interface6::sender&lt;tbb::flow::interface6::continue_msg&gt;&amp;, tbb::flow::interface6::receiver&lt;tbb::flow::interface6::continue_msg&gt;&amp;)<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;1072(%rsp), %rsi<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;88(%rsp), %rdi<br />&nbsp; &nbsp; call &nbsp; &nbsp;make_edge(tbb::flow::interface6::sender&lt;tbb::flow::interface6::continue_msg&gt;&amp;, tbb::flow::interface6::receiver&lt;tbb::flow::interface6::continue_msg&gt;&amp;)<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;560(%rsp), %rsi<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;88(%rsp), %rdi<br />&nbsp; &nbsp; call &nbsp; &nbsp;make_edge(tbb::flow::interface6::sender&lt;tbb::flow::interface6::continue_msg&gt;&amp;, tbb::flow::interface6::receiver&lt;tbb::flow::interface6::continue_msg&gt;&amp;)<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;48(%rsp), %rsi<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;1336(%rsp), %rdi<br />&nbsp; &nbsp; call &nbsp; &nbsp;make_edge(tbb::flow::interface6::sender&lt;tbb::flow::interface6::continue_msg&gt;&amp;, tbb::flow::interface6::receiver&lt;tbb::flow::interface6::continue_msg&gt;&amp;)<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;304(%rsp), %rsi<br />&nbsp; &nbsp; leaq &nbsp; &nbsp;1336(%rsp), %rdi<br />&nbsp; &nbsp; call &nbsp; &nbsp;make_edge(tbb::flow::interface6::sender&lt;tbb::flow::interface6::continue_msg&gt;&amp;, tbb::flow::interface6::receiver&lt;tbb::flow::interface6::continue_msg&gt;&amp;)<br /></pre><div><br /></div></div>